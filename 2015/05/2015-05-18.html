<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>May 18, 2015</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/css/global.css"><link rel="stylesheet" href="/diary/css/tomorrow.css"><link rel="stylesheet" href="/diary/css/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>May 18, 2015</h1></header><div class="content"><div class="diary"><h2 id="node-js">Node.js</h2>
<h3 id="-diving-into-c-internals-of-node-https-blog-indutny-com-c-cpp-in-node-"><a href="https://blog.indutny.com/c.cpp-in-node">Diving into C++ internals of node</a></h3>
<ul>
<li>Talked about some V8 optimization...well I already know them.</li>
<li>Commit history of node:<ul>
<li><code>git log deps/v8</code> and <code>git log src/</code></li>
</ul>
</li>
</ul>
<h4 id="start-61890720-https-github-com-nodejs-io-js-commit-61890720-">Start: <a href="https://github.com/nodejs/io.js/commit/61890720">61890720</a></h4>
<ul>
<li>Dependencies<ul>
<li>libebb: HTTP parser</li>
<li>liboi: TCP server framework on top of libev</li>
</ul>
</li>
<li>New Structure:<ul>
<li><code>server.cc</code>: setup V8, pass CLI arguments to JS</li>
<li><code>js_http_request_processor.cc</code>: invokes HTTP request handler</li>
</ul>
</li>
<li>One C++ instance per request, maps HTTP fields to JS object</li>
</ul>
<h4 id="api-wrapper-064c8f02-https-github-com-nodejs-io-js-commit-064c8f02-">API wrapper: <a href="https://github.com/nodejs/io.js/commit/064c8f02">064c8f02</a></h4>
<ul>
<li>API<ul>
<li><code>ObjectWrap</code> base class, maps between C++ and JS</li>
</ul>
</li>
<li>Dependencies<ul>
<li>Uses libev.</li>
</ul>
</li>
<li>New Structure:<ul>
<li><code>src/node.cc</code>: setup C++ libraries, invoke <code>src/main.js</code> for initialization<ul>
<li>From this point, things started to be written in JS as possible</li>
</ul>
</li>
<li><code>src/http.cc</code>: <code>http</code> module</li>
<li><code>src/file.cc</code>, <code>src/file.js</code>: <code>fs</code> module</li>
<li><code>src/process.cc</code>: later the <code>process</code> object</li>
<li><code>src/timers.cc</code>: timers</li>
</ul>
</li>
</ul>
<h4 id="v0-2">v0.2</h4>
<ul>
<li>Seperate JS and C++, added CommonJS, lots of new modules.</li>
<li>API<ul>
<li><code>ObjectWrap</code> became public API</li>
<li>C++ interfaces no longer global, wrapped in <code>process.binding</code>
New structure:</li>
<li><code>lib/</code> for CommonJS core modules</li>
<li><code>src/</code> their C++ counterparts</li>
<li><code>deps/</code>: V8, http-parser, c-ares(async DNS), libeio(async FS), libev(async networking and other stuff)</li>
</ul>
</li>
</ul>
<h4 id="milestone-v0-6">Milestone: v0.6</h4>
<ul>
<li>Dependencies<ul>
<li>libev -&gt; libuv</li>
</ul>
</li>
<li>Support for Windows</li>
<li>Single event-loop for both async fs and async networking</li>
</ul>
<h4 id="v0-12-and-io-js">v0.12 and io.js</h4>
<ul>
<li>Transition from <code>ObjectWrap</code>(<code>src/node_object_wrap.h</code>) to <code>AsyncWrap</code>(<code>src/async-wrap.h</code>)</li>
</ul>
<h4 id="walk-through">Walk-through</h4>
<ul>
<li><code>lib/fs.js</code>: nothing interesting, just passing the file descriptor between C++ and JS</li>
<li><code>lib/net.js</code>:  <code>tcp_wrap</code> and <code>stream_wrap</code> binding<ul>
<li><code>TCP</code>: holds the socket, r/w stuff</li>
<li><code>TCPConnectWrap</code>, <code>WriteWrap</code>, <code>ShutdownWrap</code> will be passed to <code>TCP</code> methods to do async operation and invoke callbacks</li>
</ul>
</li>
</ul>
<p>Check <a href="https://github.com/nodejs/io.js/blob/master/lib/net.js#L763">this</a> out:</p>
<blockquote>
<p>the normal workflow for <code>net.connect()</code> follows:</p>
<ol>
<li>Create <code>TCP</code> instance in <code>lib/net.js</code>, store it in the <code>_handle</code> property of the <code>net.Socket</code> object</li>
<li>Parse all arguments to <code>net.connect()</code></li>
<li>Create <code>TCPConnectWrap</code> instance (usually named <code>req</code>)</li>
<li>Invoke <code>.connect()</code> method with <code>req</code>, <code>port</code>, <code>host</code></li>
<li>Get <code>req.oncomplete</code> function invoked eventually, once the connection was established, or once the kernel reported an error</li>
</ol>
</blockquote>
<p>C++ classes are mostly handles(live longer) or requests(lives no longer than handles).</p>
<h4 id="c-structure">C++ structure</h4>
<ul>
<li><p><code>node.cc</code> register bindings using <code>NODE_MODULE_CONTEXT_AWARE_BUILTIN</code></p>
<ul>
<li>Each time <code>process.binding(&#39;moduleName&#39;)</code> is invoded, <code>node.cc</code> will look it up and initialize it</li>
<li><p>Note this:</p>
<pre><code class="lang-javascript">process.binding = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">moduleName</span>) </span>{
  <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = modules[moduleName];
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">module</span>.initialized)
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;

  <span class="hljs-built_in">module</span>.exports = {};
  <span class="hljs-built_in">module</span>.initFn(<span class="hljs-built_in">module</span>.exports);
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;
};
</code></pre>
</li>
</ul>
</li>
<li>Exported classes are bound to some C++ classes, usually derived from <code>AsyncWrap</code></li>
<li>Handles are GC&#39;ed by V8, <code>*Wrap</code>s goes with the handle</li>
<li>Two type of references from C++ to JS: normal and weak<ul>
<li><code>AysncWrap</code>s by default are normally referenced, V8 won&#39;t GC them until C++ dispose the reference</li>
<li>Weak reference are created by <code>MakeWeak</code> in C++</li>
</ul>
</li>
</ul>
<h3 id="-accelerating-oz-with-v8-follow-the-yellow-brick-road-to-javascript-performance-https-developers-google-com-events-io-sessions-324908972-"><a href="https://developers.google.com/events/io/sessions/324908972">Accelerating Oz with V8: Follow the Yellow Brick Road to JavaScript Performance</a></h3>
<ul>
<li>Jank if you can&#39;t finish the calculation within 60ms</li>
<li>GC stop the world</li>
</ul>
<h4 id="generations">Generations</h4>
<ul>
<li>Allocation is cheap until the memory pool is exhausted</li>
<li>Young generation<ul>
<li>Allocates  &amp; collects fastly</li>
<li>Frequently collected</li>
<li>High death-reate</li>
</ul>
</li>
<li>Old genreation<ul>
<li>Allocates fastly but collects slowly</li>
<li>Not frequently collected</li>
<li>Long life-time</li>
</ul>
</li>
<li><strong>Usually it&#39;s the young generation that causes the janking</strong>, cause old generation tends to live long</li>
</ul>
<h4 id="young-generation-gc">Young generation GC</h4>
<ul>
<li>To-space and from-space, splited equally</li>
<li>To-space provide memory for <code>new</code></li>
<li>From-space is used during GC</li>
<li>When to-space runs out of memory, collection is triggered<ol>
<li>To and from <strong>swaps</strong> their space</li>
<li><strong>Mark</strong> live variables in from-space(swapped in in 1), and <strong>copy</strong> them to the to-space(this is where the cost goes)</li>
<li>To-space now has more memory for allocation since dead variables are not in it</li>
</ol>
</li>
</ul>
<h4 id="optimization-and-depotimization">Optimization and depotimization</h4>
<ol>
<li><strong>Allocation</strong> draws you closer to collection, so <strong>pre-allocate</strong> as possible<ul>
<li>Audit your code, make sure there is as few <code>new</code> or <code>var</code>(implicit <code>new</code>) in frames as possible</li>
<li>V8 can optimize some implicit <code>new</code>, but not until it is hot</li>
</ul>
</li>
<li>If the code is depotimized to many times or has certain code construct(like try-catch/for-in), it will <strong>stay unoptimized</strong> forever!!</li>
<li><strong>Change of hidden class</strong> will deoptimized the code too</li>
</ol>
<h4 id="analyze">Analyze</h4>
<pre><code class="lang-bash"><span class="hljs-comment"># v8.log will show up in cwd</span>
$ Chrome --no-sandbox --js-flags=<span class="hljs-string">"--prof --noprof-lazy --log-timer-events"</span>
<span class="hljs-comment"># These tools needs to be built with V8</span>
$ tools/plot-timer-events /path/to/v8.log
<span class="hljs-comment"># platform can be mac etc.</span>
$ tools/platform-tick-processor /path/to/v8.log
$ Chrome --no-sandbox --js-flags=<span class="hljs-string">"--trace-deopt --trace-opt-verbose"</span> &gt; some.log
<span class="hljs-comment"># search for "disable optimization"</span>
</code></pre>
<p>Note GCScavenger.</p>
<ul>
<li>Trick: for un-optimizable constructs, <strong>seperate the optimizable code into a function</strong> so that the function could still be optimized</li>
</ul>
<h2 id="linux">Linux</h2>
<h3 id="-linux-internals-http-0xax-gitbooks-io-linux-insides-content-index-html-"><a href="http://0xax.gitbooks.io/linux-insides/content/index.html">Linux internals</a></h3>
<p>Looks nice, but it seems not finished yet.</p>
<h2 id="rust">Rust</h2>
<h3 id="-stanford-seminar-aaron-turon-of-mozilla-https-www-youtube-com-watch-v-o5vzlkg7y-k-"><a href="https://www.youtube.com/watch?v=O5vzLKg7y-k">Stanford Seminar - Aaron Turon of Mozilla </a></h3>
<p>No runtime, memory safety without GC, no data race.</p>
<h4 id="ownership-and-borrowing">Ownership and borrowing</h4>
<p>Root of evil: aliasing + mutation:</p>
<ol>
<li><strong>Ownership</strong> eliminates aliasing: <code>(T)</code><ul>
<li>Only one owner(can do mutation) at any given time</li>
<li>Plain type for argument implies <strong>transfer of ownership</strong></li>
<li>If the original owner wants to access the resource after transfer, compiler will complains</li>
<li>Destruction will be determined by the new owner</li>
</ul>
</li>
<li><strong>Shared borrowing()</strong> eliminates mutation: <code>(&amp; T)</code><ul>
<li>If there is aliasing, no mutation is allowed</li>
<li>If the borrower wants to mutate the resource, compiler will complains</li>
<li>Destruction will be determined by the original owner</li>
</ul>
</li>
<li><strong>Mutable borrowing</strong> restrict aliasing<ul>
<li>Only one can borrow it at a time: <code>(&amp;mut T)</code></li>
<li>Compiler will make sure there is only one borrower at a time<ul>
<li>And the same code can&#39;t be both a mutable borrower and a shared borrower</li>
</ul>
</li>
<li>Destruction will be determined by the original owner</li>
</ul>
</li>
</ol>
<h4 id="concurrency">Concurrency</h4>
<p>Root of evil: aliasing + mutation + no ordering.</p>
<p>Actor model(e.g. erlang) forbid aliasing, functional model(e.g. haskell) forbit mutation. Rust forbid both from happening simutaneously.</p>
<ol>
<li>Message passing =&gt; transfer of owenership<ul>
<li>e.g. the ownership of the sending end of a channel gets transfered, while the one creating the channel still retains the receiving end(but it will lose the sending end once it gets transfered)</li>
</ul>
</li>
<li>Shared read-only access<ul>
<li>Maintained by ARC(Atomic Reference Counter)</li>
<li>Destroyed when no one references it anymore</li>
<li>Arc owns it: <code>Arc(T)</code>, others can only borrow it: <code>&amp;T</code></li>
<li>Safe Arc, unsafe Rc</li>
</ul>
</li>
<li>Locked mutatble access<ul>
<li><code>Mutex</code></li>
<li>Destructor takes the lock, get a mutable reference to the data</li>
<li>Locks will be automitically released when the destructor&#39;s life ends</li>
<li>You can&#39;t touch the lock unless you own the lock -- ensures criticle section</li>
</ul>
</li>
</ol>
<h4 id="parallelism">Parallelism</h4>
<ul>
<li>Split and join must appear together so that the stack won&#39;t be reclaimed</li>
<li>Spawn is static, join is dynamic</li>
<li>Compiler provides type checking</li>
</ul>
<h4 id="unsafe">Unsafe</h4>
<ul>
<li>Implementation can be unsafe, but public API must guarentee safety</li>
<li>Audit by search for <code>unsafe</code></li>
<li>Tools and expreience</li>
</ul>
<h3 id="-dan-callahan-my-python-s-a-little-rust-y-pycon-2015-https-www-youtube-com-watch-v-3cwj0mh-4ma-"><a href="https://www.youtube.com/watch?v=3CwJ0MH-4MA">Dan Callahan - My Python&#39;s a little Rust-y - PyCon 2015</a></h3>
<ul>
<li>That multi-core layout thing of servo is dope. Just dope.</li>
<li>Rust-FFI-Python seems super easy.</li>
</ul>
<h2 id="css">CSS</h2>
<h3 id="-this-http-www-adobe-com-devnet-archive-html5-articles-css-shaders-html-looks-like-dark-magic-"><a href="http://www.adobe.com/devnet/archive/html5/articles/css-shaders.html">This</a> looks like dark magic...</h3>
</div></div><footer class="footer"><address class="author">Copyright &copy; <a rel="author" href="https://github.com/kevinwang04" class="author-name">kevinwang</a>-<a href="https://github.com/kevinwang04/my-tech-diary" class="source-repo">Source</a></address><p>Generated by <a href="https://github.com/joyeecheung/diary" class="site-repo">Joyee Cheung&#39;s diary generator</a></p></footer></body></html>