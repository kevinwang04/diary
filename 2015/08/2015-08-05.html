<!DOCTYPE html><!--[if lte IE 8]>
<html lang="en" class="lte-ie8">
<![endif]-->
<!--[if gt IE 8]><!-->
<html lang="en">
<!--<![endif]--><head><meta charset="utf-8"><title>August 5, 2015</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/diary/css/global.css"><link rel="stylesheet" href="/diary/css/tomorrow.css"><link rel="stylesheet" href="/diary/css/diary.css"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-63818301-1', 'auto');
ga('send', 'pageview');</script></head><body><header class="header"><div class="index"><a href="/diary/">Index</a></div><h1>August 5, 2015</h1></header><div class="content"><div class="diary"><p>react.js初体验</p>
<h2 id="-center-kevinwang-2015-08-05-center-"><center>kevinwang 2015.08.05</center></h2>
<blockquote>
<p>今天跟着react文档过了一下,体验一下当下比较火的fb出品框架.</p>
</blockquote>
<p>学习轨迹:</p>
<ul>
<li>jsx语法/较为接近html</li>
<li><p>小坑1:</p>
<ul>
<li>报错:
  Cross origin requests are only supported for protocol schemes</li>
<li>原因:
  This error is happening because you are just opening html documents directly from the browser. To fix this you will need to serve your code from a webserver and access it on localhsot</li>
<li>解决:用python启动一个服务器:
  python -m SimpleHTTPServer <strong>(python3使用python -m http.server)</strong></li>
</ul>
</li>
<li><p>问题:jsx watch 将jsx文件自动生成js文件时出现问题,待解决.</p>
<ul>
<li>已解决:1.
 jsx --whatch src/ build/ <strong>(两个目录之间有空格)</strong></li>
<li>2.变动后将script属性&quot;text/jsx&quot;改回&quot;text/javascript&quot;</li>
</ul>
</li>
<li><p>注意:</p>
<ul>
<li>如果需要在手机或平板等触摸设备上使用 React，需要调用 React.initializeTouchEvents(true); 启用触摸事件处理。</li>
</ul>
</li>
<li><p>关于state:</p>
<ul>
<li>state更新原理:常用的通知 React 数据变化的方法是调用 setState(data, callback)。这个方法会合并（merge） data 到 this.state，并重新渲染组件。</li>
<li>State 应该包括那些可能被组件的事件处理器改变并触发用户界面更新的数据。</li>
<li>不应该作为state:<ul>
<li>计算所得数据</li>
<li>react组件</li>
<li>基于props的重复数据</li>
</ul>
</li>
</ul>
</li>
<li><p>复合组件的特点/动态子集中key的使用</p>
</li>
<li><p>单向数据绑定(高效):数据通过props或者static计算的一些值从拥有者流向归属者,</p>
</li>
<li><p>性能优化:shouldComponentUpdate()方法返回 false 来让 React 跳过对子树的处理</p>
</li>
<li><p>疑问:prop验证的作用?</p>
</li>
<li><p>Refs和getDOMNode()对已挂载的DOM节点进行操作</p>
<ul>
<li>注意:getDOMNode()仅在挂载的组件上有效（也就是说，组件已经被放进了DOM中）。如果你尝试在一个未被挂载的组件上调用这个函数（例如在创建组件的render()函数中调用getDOMNode()），将会抛出异常。</li>
</ul>
</li>
<li><p>组件的生命周期:</p>
<ul>
<li>挂载<ul>
<li>getInitialState() 组件被挂载之前调用    </li>
<li>componentWillMount() 组件被挂载之前调用</li>
<li>componentDidMount() 在挂载结束之后马上被调用</li>
</ul>
</li>
<li>更新<ul>
<li>componentWillReceiveProps(object nextProps) 当一个挂载的组件接收到新的props的时候被调用</li>
<li>shouldComponentUpdate(object nextProps, object nextState): boolean当组件做出是否要更新DOM的决定的时候被调用</li>
<li>componentWillUpdate(object nextProps, object nextState) 在更新发生之前被调用。你可以在这里调用this.setState()</li>
<li>componentDidUpdate(object prevProps, object prevState)在更新发生之后调用</li>
</ul>
</li>
<li>移除<ul>
<li>componentWillUnmount()在组件移除和销毁之前被调用。清理工作应该放在这里</li>
</ul>
</li>
<li>其他挂载方法<ul>
<li>getDOMNode(): DOMElement可以在任何挂载的组件上面调用，用于获取一个指向它的渲染DOM节点的引用</li>
<li>forceUpdate()当你知道一些很深的组件state已经改变了的时候，可以在该组件上面调用，而不是使用this.setState()</li>
</ul>
</li>
</ul>
</li>
</ul>
</div></div><footer class="footer"><address class="author">Copyright &copy;<a rel="author" href="https://github.com/kevinwang04" class="author-name">kevinwang</a>-<a href="https://github.com/kevinwang04/my-tech-diary" class="source-repo">Source</a></address><p>welcome to my<a href="http://home.kwang520.com" class="site-repo"> home page</a></p></footer></body></html>